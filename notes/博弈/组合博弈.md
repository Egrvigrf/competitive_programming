# 组合博弈
## 特征
- 有两个玩家
- 游戏的操作状态是一个有限的集合（比如：限定大小的棋盘）
- 游戏双方轮流操作
- 双方的每次操作必须符合游戏规定
- 当一方不能将游戏继续进行的时候，游戏结束，同时，对方为获胜方
- 无论如何操作，游戏总能在有限次操作内结束

## 概念：必败点和必胜点（Previous点&Next点）
- 必败点：前一个选手将取胜的位置
- 必胜点：下一个选手将取胜的位置
  
## 属性
- 所有终结点是必败点
- 从任何必胜点操作，至少有一种方法可以进入必败点
- 无论如何操作，从必败点都只能进入必胜点

## 算法实现
1. 将所有终结位置标记为必败点
2. 将所有一步操作能进入必败点的位置标记为必胜点
3. 如果从某个点开始的所有的所有一步操作都只能进入必胜点，则将该点标记为必败点
4. 如果在步骤3未能找到新的必败点，则算法终止；否则，返回到步骤2 

## Nim游戏
>给定n堆石子，两位玩家轮流操作，每次操作可以从**任意一堆石子**中拿走**任意数量**的石子（可以拿完，但**不能不拿**），最后**无法进行操作的人视为失败**。问如果两人都采用**最优策略**，先手是否必胜。
### 分析
>如果每堆石子数量异或和不为0，那么先手必胜。将每堆石子的状态用一个二进制数表示，终结点的二进制数为零。这时每堆石子的二进制数都为零，进行异或操作结果也为零，此时为P点。可以进一步说明异或为0的点都为P点，异或不为零的点都为N点。对于一个每堆石子数量异或和不为0的状态，可以通过减少其中一堆石子的数量使之异或和为0(最高位等于异或和的最高位)。对于一个每堆石子数量异或和为0且未终结的状态，因为只能选择一堆石子且至少要拿走石子，所以状态必然改变，整体异或和改变后一定不为零。

## 扩展
现在我们来研究一个看上去似乎更为一般的游戏：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。事实上，这个游戏可以认为是所有Impartial Combinatorial Games的抽象模型。也就是说，任何一个ICG都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。下面我们就在有向无环图的顶点上定义Sprague-Garundy函数。

## SG函数
- sg(x)=mex{ sg(y) | y是x的后继 }
- 一个节点的sg值等于除去它的子节点的后继的最小非负整数 

### 特性
1. 终结状态的sg(x) = 0,因为终结状态没有后续节点
2. 如果一个节点x的sg(x) > 0，那么对于它后继节点必然存在y的sg(y)=0
3. 如果一个节点x的sg(x) = 0，那么它所有的后继节点y的sg(y)>0
4. 结合1.2.3.和必胜点和必败点的属性可知：对于节点x,如果sg(x) == 0,x为必败点，如果sg(x) > 0,x为必胜点。

### SG值的计算方法：（重点）
1. 可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1);
2. 可选步数为任意步，SG(x) = x;
3. 可选步数为一系列不连续的数，用模板计算。
```c++
方法二：dfs s数组是定义特殊取法规则的数组，注意要按照从小到大排序；n表示集合大小 SG函数要初始化为-1，每个集合只需初始化一遍
int s[MAXN],sg[MAXN],n;
bool vis[MAXN];
int SG_dfs(int x)
{
	if (sh[x]!=-1)
		return sg[x];
	memset(vis,0,sizeof(vis));
	for (int i=0; i<n; i++)
	{
		if (x>=s[i])
		{
			SG_dfs(x-s[i]);
			vis[sg[x-s[i]]]=1;
		}
	}
	int i=0;
	while (1)
	{
		if (!vis[i])
			return sg[x]=i;
		i++;
	}
}
```
让我们再来考虑一下顶点的SG值的意义。当g(x)=k时，表明对于任意一个0<=i<k，都存在x的一个后继y满足g(y)=i。也就是说，当某枚棋子的SG值是k时，我们可以把它变成0、变成1、……、变成k-1，但绝对不能保持k不变。不知道你能不能根据这个联想到Nim游戏，Nim 游戏的规则就是：每次选择一堆数量为k的石子，可以把它变成0、变成1、……、变成k-1，但绝对不能保持k不变。这表明，如果将n枚棋子所在的顶点的 SG值看作n堆相应数量的石子，那么这个Nim游戏的每个必胜策略都对应于原来这n枚棋子的必胜策略！
对于n个棋子，设它们对应的顶点的SG值分别为(a1,a2,...,an)，再设局面(a1,a2,...,an)时的Nim游戏的一种必胜策略是把 ai变成k，那么原游戏的一种必胜策略就是把第i枚棋子移动到一个SG值为k的顶点。

其实我们还是只要证明这种多棋子的有向图游戏的局面是P-position当且仅当所有棋子所在的位置的SG函数的异或为0。这个证明与上节的Bouton's Theorem几乎是完全相同的，只需要适当的改几个名词就行了。

刚才，我为了使问题看上去更容易一些，认为n枚棋子是在一个有向图上移动。但如果不是在一个有向图上，而是每个棋子在一个有向图上，每次可以任选一个棋子（也就是任选一个有向图）进行移动，这样也不会给结论带来任何变化。

所以我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi 并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)\^g(G2)^...^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。

再考虑在本文一开头的一句话：任何一个ICG都可以抽象成一个有向图游戏。所以“SG函数”和“游戏的和”的概念就不是局限于有向图游戏。我们给每个 ICG的每个position定义SG值，也可以定义n个ICG的和。所以说当我们面对由n个游戏组合成的一个游戏时，只需对于每个游戏找出求它的每个局面的SG值的方法，就可以把这些SG值全部看成Nim的石子堆，然后依照找Nim的必胜策略的方法来找这个游戏的必胜策略了！

## 取子游戏
>把Nim的规则略加改变：有n堆石子，每次可以从第1堆石子里取1颗、2颗或3颗，可以从第2堆石子里取奇数颗，可以从第3堆及以后石子里取任意颗……

### 分析
有n堆石子，每次可以从第1堆石子里取1颗、2颗或3颗，可以从第2堆石子里取奇数颗，可以从第3堆及以后石子里取任意颗……我们可以把它看作3个子游戏，第1个子游戏只有一堆石子，每次可以取1、2、3颗，很容易看出x颗石子的局面的SG值是x%4。第2个子游戏也是只有一堆石子，每次可以取奇数颗，经过简单的画图可以知道这个游戏有x颗石子时的SG值是x%2。第3个游戏有n-2堆石子，就是一个Nim游戏。对于原游戏的每个局面，把三个子游戏的SG值异或一下就得到了整个游戏的SG值，然后就可以根据这个SG值判断是否有必胜策略以及做出决策了。其实看作3个子游戏还是保守了些，干脆看作n个子游戏，其中第1、2个子游戏如上所述，第3个及以后的子游戏都是“1堆石子，每次取几颗都可以”，称为“任取石子游戏”，这个超简单的游戏有x颗石子的SG值显然就是x。其实，n堆石子的Nim游戏本身不就是n个“任取石子游戏”的和吗？

