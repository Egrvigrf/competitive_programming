# 哈希函数
哈希函数的用处
把复杂样本变成数字，以后复杂样本之间的对比，就变成了数字之间的对比

哈希函数的基本性质
1）输入参数的可能性是无限的，输出的值范围相对有限
2）输入同样的样本一定得到同样的输出值，也就是哈希函数没有任何随机机制
3）输入不同的样本也可能得到同样的输出值，此时叫哈希碰撞
4）输入大量不同的样本，得到的大量输出值，会几乎均匀的分布在整个输出域上

哈希函数的种类很多，但都符合上述性质
性质4是最重要的，哈希碰撞理论上无法避免，但是好的哈希函数会让碰撞几率变的很低

可以把性质4直观理解为：
不管有没有规律，也不管多么相似，总之一堆不同的输入，得到的输出结果从分布上看，熵最大！



# 字符串哈希算法

字符串哈希算法是一种将字符串映射为一个整数（哈希值）的技术，这样可以在常数时间内比较字符串。
这种方法特别适用于需要频繁比较字符串的场景，如字符串查找、文本处理和数据结构（如哈希表）等。

如何快速得到字符串中任意子串的哈希值
1）选择一个质数$base$做进制数，
2）得到$base$的各种次方，在自然溢出下的结果，用$pow$数组记录
3）得到每个位置的$hash[i]$:
$$ hash[i] = hash[i-1] * base + s[i] - 'a' + 1 $$
4）子串$s[l...r]$的哈希值 = hash[r] $- hash[l-1]   *   base ^(r-l+1)  （在从l到r更新的过程中每项多了base^(r-l+1)）

# 自然溢出
```cpp
int base = 1313;
ll hash_(string& s) {
    ll ans = 0;
    for(int i = 0; i < s.size(); i++) {
        ans = ans*base + s[i] - 'a' + 1;
    }
    return ans;
}
```

常用base: 31、131、1313、13131、131313
质数：433、499、599、1000000007
得到子串哈希O(1)
比较一个字符串中的两个子串是否相等的时间复杂度能从O(n)降低到O(1)
```cpp
int base = 1313;
ll hash_[n+1];
ll power[n+1];
for(int i = 0; i <= s.size(); i++) {
    power[i] = power[i-1]*base;
    hash_[i] = hash_[i-1]*base + s[i] - 'a' + 1;
}
ll hash1 = hash_[r] - hash_[l]*power[r-l+1];
```


随机base
```cpp
mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());
//jiangly 范围[0,2^64-1]
```