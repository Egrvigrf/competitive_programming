# 线性丢番图方程解的存在性证明

线性丢番图方程（Linear Diophantine Equation）是形如 \(ax + by = c\) 的方程，其中 \(a\)、\(b\)、\(c\) 是已知整数，\(x\) 和 \(y\) 是未知整数。要讨论解的存在性，我们需要用到最大公约数（gcd）的概念。

线性丢番图方程 \(ax + by = c\) 有整数解的充要条件是：\(c\) 是 \(a\) 和 \(b\) 的最大公约数的倍数。即：

\[ \gcd(a, b) \mid c \]

## 证明

我们可以通过贝祖定理（Bézout's Theorem）来证明这个条件。

### 必要性

假设 \(ax + by = c\) 有整数解，即存在整数 \(x\) 和 \(y\) 使得这个等式成立。设 \(d = \gcd(a, b)\)，那么根据最大公约数的定义，\(d\) 能同时整除 \(a\) 和 \(b\)。因此，我们可以写成：

\[ a = d \cdot a_1 \]
\[ b = d \cdot b_1 \]

其中 \(a_1\) 和 \(b_1\) 是整数，并且 \(\gcd(a_1, b_1) = 1\)。

将这些表达式代入原方程：

\[ d \cdot a_1 \cdot x + d \cdot b_1 \cdot y = c \]

可以提取出 \(d\)：

\[ d(a_1 x + b_1 y) = c \]

因为 \(d\) 是 \(a\) 和 \(b\) 的最大公约数，所以 \(a_1 x + b_1 y\) 是一个整数。设 \(k = a_1 x + b_1 y\)，那么我们有：

\[ d \cdot k = c \]

这意味着 \(c\) 必须是 \(d\) 的倍数，因此 \( \gcd(a, b) \mid c \)。

### 充分性

我们还需要证明如果 \(\gcd(a, b) \mid c\)，那么方程 \(ax + by = c\) 有整数解。

假设 \(\gcd(a, b) = d\)，且 \(d \mid c\)。那么我们可以写成：

\[ c = d \cdot k \]

因为 \(d = \gcd(a, b)\)，根据贝祖定理，存在整数 \(x_0\) 和 \(y_0\) 使得：

\[ a x_0 + b y_0 = d \]

将这个等式乘以 \(k\)：

\[ a (kx_0) + b (ky_0) = dk \]

因为 \(c = dk\)，所以：

\[ a (kx_0) + b (ky_0) = c \]

设 \(x = kx_0\)，\(y = ky_0\)，那么：

\[ ax + by = c \]

这表明方程 \(ax + by = c\) 有整数解。

## 总结

线性丢番图方程 \(ax + by = c\) 有整数解的充要条件是：

\[ \gcd(a, b) \mid c \]

这意味着 \(c\) 必须是 \(a\) 和 \(b\) 的最大公约数的倍数。这个条件既是必要的也是充分的。

# 贝祖定理

贝祖定理（Bézout's theorem）是数论中的一个重要定理，它描述了在整数范围内，两个整数的最大公约数与这两个整数的线性组合之间的关系。具体来说，贝祖定理表述如下：

对于任意的非零整数 \( a \) 和 \( b \)，存在整数 \( x \) 和 \( y \)，使得：
\[ ax + by = \gcd(a, b) \]

其中，\(\gcd(a, b)\) 表示 \( a \) 和 \( b \) 的最大公约数。

## 例子

假设 \( a = 30 \) 和 \( b = 20 \)。我们计算它们的最大公约数：
\[ \gcd(30, 20) = 10 \]

根据贝祖定理，应该存在整数 \( x \) 和 \( y \)，使得：
\[ 30x + 20y = 10 \]

我们可以通过扩展欧几里得算法（Extended Euclidean Algorithm）找到这样的 \( x \) 和 \( y \)。具体过程如下：

1. 使用欧几里得算法找到 \( \gcd(30, 20) \)：
   \[
   \begin{align*}
   30 &= 1 \times 20 + 10 \\
   20 &= 2 \times 10 + 0
   \end{align*}
   \]

   所以，\(\gcd(30, 20) = 10\)。

2. 回代求解贝祖系数：
   \[
   10 = 30 - 1 \times 20
   \]

   因此，\( x = 1 \) 和 \( y = -1 \)，满足：
   \[ 30 \times 1 + 20 \times (-1) = 10 \]

## 扩展欧几里得算法

扩展欧几里得算法（Extended Euclidean Algorithm）是欧几里得算法的一个扩展版本，用于在计算两个整数的最大公约数（GCD）的同时，找到满足贝祖等式（Bézout's identity）的系数。这些系数是使得以下等式成立的整数 \( x \) 和 \( y \)：

\[ ax + by = \gcd(a, b) \]

### 算法步骤

1. **基本情况**：
   - 如果 \( b = 0 \)，则 \( \gcd(a, b) = a \)。此时，\( x = 1 \)，\( y = 0 \)。

2. **递归情况**：
   - 如果 \( b \neq 0 \)，则用递归的方法计算 \( b \) 和 \( a \% b \) 的最大公约数，同时计算对应的系数。
   - 设 \( \gcd(b, a \% b) = d \)，则存在整数 \( x_1 \) 和 \( y_1 \)，使得：
     \[ bx_1 + (a \% b)y_1 = d \]
   - 由于 \( a \% b = a - (a / b) \cdot b \)，我们可以将上式改写为：
     \[ bx_1 + (a - (a / b) \cdot b)y_1 = d \]
   - 进而得到：
     \[ a y_1 + b(x_1 - (a / b) y_1) = d \]
   - 因此，新的系数 \( x \) 和 \( y \) 可以表示为：
     \[ x = y_1 \]
     \[ y = x_1 - (a / b) y_1 \]

### C++ 实现

下面是扩展欧几里得算法的 C++ 实现：

```cpp
#include <iostream>

// 扩展欧几里得算法
int extendedGCD(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    int x1, y1;
    int gcd = extendedGCD(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return gcd;
}

int main() {
    int a = 30, b = 20;
    int x, y;
    int gcd = extendedGCD(a, b, x, y);
    std::cout << "gcd(" << a << ", " << b << ") = " << gcd << std::endl;
    std::cout << "Coefficients: x = " << x << ", y = " << y << std::endl;
    std::cout << a << " * " << x << " + " << b << " * " << y << " = " << gcd << std::endl;
    return 0;
}
