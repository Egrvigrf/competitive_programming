# 哈夫曼树
给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

## 1.路径和路径长度
在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。
## 2.节点的权和带权路径长度
若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
## 3.树的带权路径长度
树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。
## 哈夫曼树的构造
假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：

1.  将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；

2.  在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；

3. 从森林中删除选取的两棵树，并将新树加入森林；

4. 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

## 优先队列实现WPL
```cpp
int bfs()
{
    int a, b, sum = 0;
    priority_queue<int, vector<int>, greater<int> > q;
    for (int i = 0; i <= 26; i++)
    {
        if (num[i])
            q.push(num[i]);
    }
    if (q.size() == 1)
        sum = q.top0;
    while (q.size() > 1)
    {
        a = q.top();
        q.pop();
        b = q.top();
        q.pop();
        sum += a + b;
        q.push(a + b);
        return sum;
    }
}
```